#' Specify and sample a brms model
#' @param name A character string indicating the name to be assigned to the model
#' @param ... Arguments to be passed to \code{brms::brm()}
fit_model <- function(name, ...) {
    # we run the model in the background as an RStudio job to keep the console free
    # see R/utils.R
    fit <- brm(
        ...,
        iter = 1000,
        cores = 4,
        chains = 4,
        init = 0.5,
        seed = 888,
        backend = "cmdstanr",
        file = glue("results/fits/{name}.rds"),
        file_refit = "on_change",
        control = list(adapt_delta = 0.9,
                       max_treedepth = 15),
        save_model = glue("stan/{name}.stan")
    )
    
    saveRDS(fit, "bvq-app/data/fit.rds")
    
    return(fit)
}

#' Extract posterior draws of fixed effect coefficients from brmsfit model via \code{tidybayes::gather_draws}.
#' 
#' @param model A brmsfit object
#' @param data Dataset of resposnes as generated by the \code{get_responses} function
#' @param ... Arguments to be passed to \code{tidybayes::gather_draws}
get_posterior_draws <- function(model,
                                data,
                                rope_interval = c(lower = -0.1,
                                                  upper = +0.1),
                                ...) {
    # tidy predictor names
    str_repl <- c(
        "b_Intercept[1]" = "Comprehension and Production",
        "b_Intercept[2]" = "Comprehension",
        "b_age_std" = glue("Age (+1 SD, {round(sd(data$age), 2)} months)"),
        "b_lp1" = "Group (Monolingual vs. Bilingual)",
        "b_dominance1" = "Dominance (L1 vs. L2)",
        "b_lp1:dominance1" = "Group \u00d7 Dominance"
    )
    
    # posterior draws
    posterior_draws <- gather_draws(model, `b_.*`, regex = TRUE, ...) |>
        mutate(
            .variable_name = factor(.variable,
                                    levels = names(str_repl),
                                    labels = str_repl) |>
                as.character(),
            type = ifelse(
                str_detect(.variable, "Intercept"),
                glue("Intercepts (at {round(mean(data$age, 2))} months)"),
                "Slopes"
            ),
            parameter = ifelse(
                str_detect(.variable, "Intercept"),
                str_remove_all(.variable, "Intercept \\(|\\)"),
                .variable
            )
        ) |>
        select(.variable, .variable_name, .type = type, 
               .chain, .iteration, .draw, .value) |>
        ungroup()
    
    # posterior summary
    posterior_summary <- describe_posterior(model,
                                            test = "rope",
                                            rope_range = rope_interval,
                                            ci_method = "HDI",
                                            ...) |>
        as_tibble() |>
        clean_names() |>
        mutate(.variable_name = factor(
            parameter,
            levels = names(str_repl),
            labels = str_repl) |>
                as.character(),
            type = ifelse(str_detect(parameter, "Intercept"),
                          glue("Intercepts (at {round(mean(data$age, 2))} months)"),
                          "Slopes"),
            parameter = ifelse(str_detect(parameter, "Intercept"),
                               str_remove_all(parameter, "Intercept \\(|\\)"),
                               parameter)) |>
        select(.variable = parameter,
               .variable_name,
               .type = type,
               .median = median,
               .upper = ci_high,
               .lower = ci_low,
               .rope_overlap = rope_percentage) |>
        ungroup()
    
    # make list with posterior
    posterior <- list()
    posterior$summary <- posterior_summary
    posterior$draws <- posterior_draws
    
    # export draws
    save_files(posterior_draws, folder = "results/posterior")
    saveRDS(posterior_draws, "bvq-app/data/posterior.rds")
    
    return(posterior)
}

#' Generate dataset with posterior predictions from a brmsfit model
#'
#' @param model A brmsfit object
#' @param data Data with which the model was fist, containing the original variables
#' @param group Group for which posterior predictions will be generated. If `NULL` (default), posterior predictions will be generated for fixed effect. If `"te"`, predictions will be generated for translation equivalents. If `"id"`, predictions will be generated for participants.
#' @param levels If group is `"te"` or `"id"`, specific levels (translation equivalents or participants) can be specified. If NULL (default), posterior predictions are generated for all levels of the grouping variable.
#' @inheritParams marginaleffects::datagrid
generate_newdata <- function(model,
                             data,
                             group = NULL,
                             levels = NULL,
                             ...) {
    # some checks
    if (!is.null(group)) {
        if (!(group %in% c("te", "id")) | length(group) > 1) {
            cli_abort("group must be one of 'te' or 'id")
        }
    }
    
    # make sure that all levels exist in the dataset
    if (!is.null(levels)) {
        levels_in_data <- levels %in% data[[group]]
        if (!all(levels_in_data)) {
            missing_levels <- paste0(levels[!levels_in_data], collapse = ", ")
            cli_abort("Level {missing_levels} in {.field {group}} is missing")
        }
    }
    
    # data frame with prediction combinations
    if (is.null(group)) {
        nd <- datagrid(model = model, te = NA, id = NA, ...)
    } else {
        # expand predictor levels in data frame to generate predictions
        if (group == "te") {
            # if group is "te", generate predictions for each level of `te`
            nd <- datagrid(model = model, te = levels, id = NA, ...) |>
                left_join(distinct(data, te))
        }
        if (group == "id") {
            # expand predictor levels in data frame to generate predictions
            nd <- datagrid(model = model, id = levels, te = NA, ...) |>
                select(-age_std) |>
                left_join(distinct(data, id, age_std))
        }
    }
    
    return(nd)
}




