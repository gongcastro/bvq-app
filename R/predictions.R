#' Generate dataset with posterior predictions from a brmsfit model
#'
#' @param model A brmsfit object
#' @param data Data with which the model was fist, containing the original variables
#' @param group Group for which posterior predictions will be generated. If `NULL` (default), posterior predictions will be generated for fixed effect. If `"te"`, predictions will be generated for translation equivalents. If `"id"`, predictions will be generated for participants.
#' @param levels If group is `"te"` or `"child_id"`, specific levels (translation equivalents or participants) can be specified. If NULL (default), posterior predictions are generated for all levels of the grouping variable.
#' @inheritParams marginaleffects::datagrid
generate_newdata <- function(model,
                             data,
                             group = NULL,
                             levels = NULL,
                             ...) {
    # if group(s) specified (and valid), extract desired levels
    if (!is.null(group)) {
        check_arg_group <- group %in% c("te", "child_id") | length(group) > 1
        if (!check_arg_group) {
            cli_abort("group must be one of 'te' or 'child_id")
        }

        # make sure that all levels exist in the dataset
        if (!is.null(levels)) {
            levels_in_data <- levels %in% data[[group]]
            if (!all(levels_in_data)) {
                missing_levels <- paste0(levels[!levels_in_data], collapse = ", ")
                cli::cli_abort("Level {missing_levels} in {.field {group}} is missing")
            }
        } else {
            levels <- unique(data[[group]])
        }

        if (group == "te") {
            # if group is "te", generate predictions for each level of `te`
            newdata <- marginaleffects::datagrid(model = model,
                                                 te = levels,
                                                 child_id = NA,
                                                 ...) |>
                left_join(distinct(data, te), by = join_by(te))
        }

        if (group == "id") {
            # expand predictor levels in data frame to generate predictions
            newdata <- marginaleffects::datagrid(model = model,
                                                 child_id = levels,
                                                 te = NA,
                                                 dominance = c("L1", "L2")) |>
                left_join(distinct(data, child_id, age_std, lp),
                          by = join_by(age_std, lp, id))
        }
    } else {
        newdata <- marginaleffects::datagrid(model = model, te = NA, child_id = NA, ...)
    }

    return(newdata)
}

#' Generate posterior predictions for fixed effects brmsfit model via [marginaleffects::predictions()]
#'
#' @param model A brmsfit object
#' @param data Data with the desired combination of levels of the predictors for which to generate posterior predictions, as generated by [generate_newdata()]
#' @inheritParams marginaleffects::datagrid
posterior_predictions <- function(model, data, ...) {
    # generate data for predictions
    newdata <- generate_newdata(model, data, ...)

    # use marginaleffects to get posterior means
    predictions <- marginaleffects::predictions(model,
                                                newdata = newdata,
                                                re_formula = NA,
                                                vcov = FALSE,
                                                ndraws = 100) |>
        marginaleffects::posteriordraws() |> # so that each draw gets a row
        tibble::as_tibble() |>
        janitor::clean_names() |>
        dplyr::filter(group != "No") |>
        pivot_wider(id_cols = any_of(c("drawid", colnames(newdata))),
                    names_from = group,
                    values_from = draw) |>
        mutate(`Understands` = `Understands and Says` + `Understands`) |>
        pivot_longer(c(`Understands`, `Understands and Says`),
                     names_to = "group",
                     values_to = "draw") |>
        select(any_of(colnames(newdata)),
               .category = group,
               .draw = drawid,
               .value = draw)

    # save predictions as Parquet file
    save_files(predictions, folder = "results/predictions")
    arrow::write_dataset(predictions,
                         path = "bvq-app/data/predictions",
                         format = "parquet",
                         partitioning = c("dominance", "lp"))

    return(predictions)
}

#' Generate posterior predictions for fixed effects brmsfit model via [marginaleffects::predictions()]
#'
#' @param model A brmsfit object
#' @param data Data with the desired combination of levels of the predictors for which to generate posterior predictions, as generated by \code{generate_newdata}
#' @param group Group level for which posterior predictions are generated. Takes `"te"` or `"id"` as values.
#' @param ... Additional arguments passed to [marginaleffects::predictions()]
posterior_predictions_re <- function(model, data, group, ...) {

    # check_arg_group <- group %in% c("child_id", "te")
    # if (!check_arg_group) {
    #     cli_abort("group must be 'child_id' or 'te'")
    # }

    # generate data for predictions
    newdata <- generate_newdata(model, data, group, ...)

    # use marginaleffects to get posterior means
    re_form <- as.formula(paste0("~ 1 | ", group))
    predictions <- marginaleffects::predictions(model,
                                                newdata = newdata,
                                                re_formula = re_form,
                                                vcov = FALSE,
                                                ndraws = 100) |>
        marginaleffects::posteriordraws() |> # so that each draw gets a row
        tibble::as_tibble() |>
        janitor::clean_names() |>
        dplyr::filter(group != "No") |>
        pivot_wider(id_cols = c(drawid, age_std, dominance, lp, te, child_id),
                    names_from = group,
                    values_from = draw) |>
        mutate(`Understands` = `Understands and Says` + `Understands`) |>
        pivot_longer(c(`Understands`, `Understands and Says`),
                     names_to = "group",
                     values_to = "draw") |>
        select(any_of(colnames(newdata)),
               .category = group,
               .draw = drawid,
               .value = draw)

    if (group == "te") {
        predictions_te <- predictions
        # export results
        save_files(predictions_te, folder = "results/predictions")
        saveRDS(predictions, file.path("bvq-app", "data", "predictions_te.rds"))
        arrow::write_dataset(predictions_te,
                             path = "bvq-app/data/predictions_te",
                             format = "parquet",
                             partitioning = "te")
        predictions_re <- predictions_te
    }

    if (group == "id") {
        predictions_id <- predictions
        # export results
        save_files(predictions_id, folder = "results/predictions")
        arrow::write_dataset(predictions_id,
                             path = "bvq-app/data/predictions_child_id",
                             format = "parquet",
                             partitioning = "child_id")
        predictions_re <- predictions_id
    }

    return(predictions_re)
}
